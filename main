#!/usr/bin/env python3.6

""" 2048 in python 3
    Game can be played manually or automatic """

import sys
import os
import time
from lib.game import Game

def manual_game():
    """ Play the 2048 manually """

    # Load an empty game
    game = Game()

    # Set keybinds
    keys = {
        "left": "a",
        "right": "d",
        "down": "s",
        "up": "w",
        "quit": "q"
    }

    reversed_keys = {v: k for k, v in keys.items()}

    print("Press {} to move left.".format(keys["left"]))
    print("Press {} to move right.".format(keys["right"]))
    print("Press {} to move down.".format(keys["down"]))
    print("Press {} to move up.".format(keys["up"]))
    print("Press {} to quit the game.\n".format(keys["quit"]))
    print("Enjoy!\n___________________\n")

    possible_directions = game.possible_directions(game.board.board)
    game.game_over = len(possible_directions) == 0
    fancy_render(game.board.board, game.score, None, game.moves)

    while not game.game_over:
        # Keyboard input (press and release is not working, so we use time.sleep)
        key = read_single_keypress()
        if key in reversed_keys:
            direction = reversed_keys[key]

        if direction == "quit":
            sys.exit()

        # Perform a movement
        if direction in possible_directions:
            game.perform_movement(direction)
            fancy_render(game.board.board, game.score, direction, game.moves)

        # Check if the game has been won
        for row in game.board.board:
            if 2048 in row:
                print("\nYou have won the game!!! \n")
                break

        # Duplicate the board to determine the possible directions
        duplicated_board = game.board.duplicate()
        possible_directions = game.possible_directions(duplicated_board.board)
        game.game_over = len(possible_directions) == 0



    print("\n\n\nGame over!\nFinal score: {}".format(game.score))

def automatic_game(render_game=False):
    """ Play the 2048 automatically using the ai script """

    total_games = 10
    sleeping_time = 0

    game_scores = {}
    for game_i in range(total_games):
        game = Game()
        games_won = 0

        print("Current game: {}".format(game_i+1))
        if render_game:
            fancy_render(game.board.board, game.score, None, game.moves)

        duplicated_board = game.board.duplicate()
        possible_directions = game.possible_directions(duplicated_board.board)
        game.game_over = len(possible_directions) == 0

        while not game.game_over:

            direction = algo.determine_best_movement(duplicated_board.board, possible_directions)

            # Perform a movement
            game.perform_movement(direction)

            if render_game:
                fancy_render(game.board.board, game.score, direction, game.moves)
                print("Current game: {}".format(game_i+1))

            # Check if the game has been won
            # Duplicate the board to determine the possible directions
            duplicated_board = game.board.duplicate()
            possible_directions = game.possible_directions(duplicated_board.board)
            game.game_over = len(possible_directions) == 0

            time.sleep(sleeping_time)

            if game.game_over:
                for row in game.board.board:
                    for value in row:
                        if value >= 2048:
                            games_won += 1


        game_scores[game_i+1] = game.score

    if total_games < 100:
        print("\nScores per game: \n{}".format(game_scores))
        print("The algo has beaten {} games".format(games_won))

def fancy_render(board, score, direction, moves):
    """ A more advanced version of the render function """

    # Set the width of the board
    board_spacing = 10

    # Build tile spacing
    tile_spacing = "".join([" " for _ in range(board_spacing)])
    tile_spacing = "||".join([tile_spacing, tile_spacing, tile_spacing, tile_spacing])

    # Build midline
    midline = "".join(["_" for _ in range(board_spacing)])
    midline = "00".join([midline, midline, midline, midline])

    # Build the board
    total_board = ""
    for i, row in enumerate(board):

        # Build the tiles
        tiles = list(map(lambda n: str(" " if n == 0 else n).center(board_spacing, " "), row))
        line = "||".join(tiles)

        if i == 0:
            total_board = "\n".join([tile_spacing, line, tile_spacing])
        else:
            total_board = "\n".join([total_board, midline, tile_spacing, line, tile_spacing])

    # Print the board on the screen
    print(
        """
        \n\n\n\n\n\n\n\n\n{}\nMovement: {}\nScore: {}\nMoves: {}
        """.format(total_board, direction, score, moves)
    )

def read_single_keypress():
    """Waits for a single keypress on stdin.

    This is a silly function to call if you need to do it a lot because it has
    to store stdin's current setup, setup stdin for reading single keystrokes
    then read the single keystroke then revert stdin back after reading the
    keystroke.

    Returns the character of the key that was pressed (zero on
    KeyboardInterrupt which can happen when a signal gets handled)

    Function obtained from:
    https://stackoverflow.com/questions/983354/how-do-i-make-python-wait-for-a-pressed-key
    """

    f_d = sys.stdin.fileno()
    # save old state
    flags_save = fcntl.fcntl(f_d, fcntl.F_GETFL)
    attrs_save = termios.tcgetattr(f_d)
    # make raw - the way to do this comes from the termios(3) man page.
    attrs = list(attrs_save) # copy the stored version to update
    # iflag
    attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK
                  | termios.ISTRIP | termios.INLCR | termios. IGNCR
                  | termios.ICRNL | termios.IXON)
    # oflag
    attrs[1] &= ~termios.OPOST
    # cflag
    attrs[2] &= ~(termios.CSIZE | termios. PARENB)
    attrs[2] |= termios.CS8
    # lflag
    attrs[3] &= ~(termios.ECHONL | termios.ECHO | termios.ICANON
                  | termios.ISIG | termios.IEXTEN)
    termios.tcsetattr(f_d, termios.TCSANOW, attrs)
    # turn off non-blocking
    fcntl.fcntl(f_d, fcntl.F_SETFL, flags_save & ~os.O_NONBLOCK)
    # read a single keystroke
    try:
        ret = sys.stdin.read(1) # returns a single character
    except KeyboardInterrupt:
        ret = 0
    finally:
        # restore old state
        termios.tcsetattr(f_d, termios.TCSAFLUSH, attrs_save)
        fcntl.fcntl(f_d, fcntl.F_SETFL, flags_save)
    return ret

def get_game_type():
    """
    let the player choose between game types using input
    'm' = manual game in the terminal
    'a' = automatic game in the terminal
    """
    game_type = ""
    # Determine if it is a manual or automatic game
    while game_type not in ["m", "a"]:
        game_type = input("(M)anual game or (A)utoplay?\n").lower()

    return game_type

def determine_retry():
    """ Let the player choose to retry playing the game """
    retry = input("Do you want a retry? (Y)es/(N)o?").lower()
    while retry not in ("y", "n"):
        retry = input("Do you want a retry? (Y)es/(N)o?").lower()

    return retry

# Determine if it is a manual or automatic game
GAME_TYPE = get_game_type()

if GAME_TYPE == "m":
    import termios
    import fcntl

    PLAYING = True
    while PLAYING:
        manual_game()

        if determine_retry() == "n":
            print("Thanks for playing!")
            break



elif GAME_TYPE == "a":
    import lib.network as algo

    automatic_game()
    print("Still in progress...")
