#!/usr/bin/env python3.6

""" 2048 in python 3
    Game can be played manually or automatic """

import sys
import os
from lib.game import Game

def manual_game():
    """ Play the 2048 manually """

    # Load an empty game
    game = Game()

    # Set keybinds
    keys = {
        "left": "a",
        "right": "d",
        "down": "s",
        "up": "w",
        "quit": "q"
    }

    reversed_keys = {v: k for k, v in keys.items()}

    print("Press {} to move left.".format(keys["left"]))
    print("Press {} to move right.".format(keys["right"]))
    print("Press {} to move down.".format(keys["down"]))
    print("Press {} to move up.".format(keys["up"]))
    print("Press {} to quit the game.\n".format(keys["quit"]))
    print("Enjoy!\n___________________\n")

    fancy_render(game.board.board, game.score, None)
    while not game.game_over():

        # Keyboard input
        direction = reversed_keys[read_single_keypress()]

        if direction == "quit":
            sys.exit()

        elif game.perform_movement(direction):
            fancy_render(game.board.board, game.score, direction)

def automatic_game():
    """ Play the 2048 automatically using the ai script """
    total_games = 1

    for game_i in range(total_games):
        game = Game()
    print("Test")

def fancy_render(board, score, direction):
    """ A more advanced version of the render function """

    # Set the width of the board
    board_spacing = 10

    # Build tile spacing
    tile_spacing = "".join([" " for _ in range(board_spacing)])
    tile_spacing = "||".join([tile_spacing, tile_spacing, tile_spacing, tile_spacing])

    # Build midline
    midline = "".join(["_" for _ in range(board_spacing)])
    midline = "00".join([midline, midline, midline, midline])

    # Build the board
    total_board = ""
    for i, row in enumerate(board):

        # Build the tiles
        tiles = list(map(lambda n: str(" " if n == 0 else n).center(board_spacing, " "), row))
        line = "||".join(tiles)

        if i == 0:
            total_board = "\n".join([tile_spacing, line, tile_spacing])
        else:
            total_board = "\n".join([total_board, midline, tile_spacing, line, tile_spacing])

    # Print the board on the screen
    print("\n\n\n\n\n\n\n\n\nMovement: {}\n\n{}\n\nScore: {}".format(direction, total_board, score))

def read_single_keypress():
    """Waits for a single keypress on stdin.

    This is a silly function to call if you need to do it a lot because it has
    to store stdin's current setup, setup stdin for reading single keystrokes
    then read the single keystroke then revert stdin back after reading the
    keystroke.

    Returns the character of the key that was pressed (zero on
    KeyboardInterrupt which can happen when a signal gets handled)

    Function obtained from:
    https://stackoverflow.com/questions/983354/how-do-i-make-python-wait-for-a-pressed-key
    """

    f_d = sys.stdin.fileno()
    # save old state
    flags_save = fcntl.fcntl(f_d, fcntl.F_GETFL)
    attrs_save = termios.tcgetattr(f_d)
    # make raw - the way to do this comes from the termios(3) man page.
    attrs = list(attrs_save) # copy the stored version to update
    # iflag
    attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK
                  | termios.ISTRIP | termios.INLCR | termios. IGNCR
                  | termios.ICRNL | termios.IXON)
    # oflag
    attrs[1] &= ~termios.OPOST
    # cflag
    attrs[2] &= ~(termios.CSIZE | termios. PARENB)
    attrs[2] |= termios.CS8
    # lflag
    attrs[3] &= ~(termios.ECHONL | termios.ECHO | termios.ICANON
                  | termios.ISIG | termios.IEXTEN)
    termios.tcsetattr(f_d, termios.TCSANOW, attrs)
    # turn off non-blocking
    fcntl.fcntl(f_d, fcntl.F_SETFL, flags_save & ~os.O_NONBLOCK)
    # read a single keystroke
    try:
        ret = sys.stdin.read(1) # returns a single character
    except KeyboardInterrupt:
        ret = 0
    finally:
        # restore old state
        termios.tcsetattr(f_d, termios.TCSAFLUSH, attrs_save)
        fcntl.fcntl(f_d, fcntl.F_SETFL, flags_save)
    return ret

def get_game_type():
    """
    let the player choose between game types using input
    'm' = manual game in the terminal
    'a' = automatic game in the terminal
    """
    game_type = ""
    # Determine if it is a manual or automatic game
    while game_type not in ["m", "a"]:
        game_type = input('(M)anual game or (A)utoplay?\n').lower()

    return game_type

# Determine if it is a manual or automatic game
GAME_TYPE = get_game_type()

if GAME_TYPE == "m":
    import termios
    import fcntl

    manual_game()

elif GAME_TYPE == "a":
    automatic_game()
    print("Still in progress...")
