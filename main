#!/usr/bin/env python3.6

""" 2048 in python 3
    Game can be played manually or automatic """

import sys
import os
import time
from lib.game import Game
import lib.game_tools as game_tools

def manual_game():
    """ Play the 2048 manually """

    # Set keybinds
    keys = {
        "left": "a",
        "right": "d",
        "down": "s",
        "up": "w",
        "quit": "q"
    }
    reversed_keys = {v: k for k, v in keys.items()}

    for game_index in range(1, ARGS.total_games+1):

        # Load an empty game
        game = Game()

        possible_directions = game.possible_directions(game.board.board)
        game.game_over = len(possible_directions) == 0
        game_tools.render_manual_in_terminal(keys, game.board.board, game.score, None, game.moves)

        while not game.game_over:
            # Keyboard input (press and release is not working, so we use time.sleep)
            # key = game_tools.read_single_keypress().lower()
            # direction = reversed_keys[key] if key in reversed_keys else None
            import random
            direction = random.choice(possible_directions)

            if direction == "quit":
                sys.exit()

            # Perform a movement
            if direction in possible_directions:
                game.perform_movement(direction)
                #TODO add hinting
                # hint = algo.determine_best_movement(game.board.board, possible_directions)
                game_tools.render_manual_in_terminal(
                    keys, game.board.board, game.score, direction, game.moves
                )

            # Check if the game has been won
            for row in game.board.board:
                if 2048 in row:
                    print("\nYou have won the game!!! \n")
                    break

            # Duplicate the board to determine the possible directions
            duplicated_board = game.board.duplicate()
            possible_directions = game.possible_directions(duplicated_board.board)
            game.game_over = len(possible_directions) == 0

        # Game is over, rematch???
        print("\n\n\nGame over!\nFinal score: {}".format(game.score))
        if game_index != ARGS.total_games:
            rematch = "."
            while rematch not in ("", "q"):
                rematch = input("Continue (enter) or quit (q)?\n")
                rematch = rematch.lower()

            if rematch == "q":
                print("Thanks for playing!")
                break

def automatic_game():
    """ Play the 2048 automatically using the ai script """

    # render_game = True
    total_games = ARGS.total_games
    sleeping_time = 0.2

    # play x games
    game_scores = {}
    games_won = 0
    for game_index in range(1, total_games+1):
        game = Game()

        # Render board if render_game is True
        if ARGS.render:
            game_tools.render_automatic_in_terminal(
                game.board.board, game.score, None, game.moves, game_index
            )
            time.sleep(sleeping_time)
        else:
            print(f"Games played: {game_index}/{total_games}", end="\r")

        #Play a single game
        while not game.game_over:

            # Duplicate the board to determine the possible directions
            #TODO can we remove the duplicated boaard??
            duplicated_board = game.board.duplicate()
            possible_directions = game.possible_directions(duplicated_board.board)

            if len(possible_directions) == 0:
                game.game_over = True
                break

            # Let the algorithm choose the best direction to perform
            direction = algo.determine_best_movement(duplicated_board.board, possible_directions)

            # Perform a movement
            game.perform_movement(direction)

            # Render board if render_game is True
            if ARGS.render:
                game_tools.render_automatic_in_terminal(
                    game.board.board, game.score, direction, game.moves, game_index
                )
                algo.determine_best_movement(duplicated_board.board, possible_directions, True)
                time.sleep(sleeping_time)

        # Determine if the game has been won
        game_won = False
        for row in game.board.board:
            for value in row:
                if value >= 2048:
                    game_won = True

                if games_won:
                    games_won += 1
                    break

            if games_won:
                break

        # Save the score of the game
        game_scores[game_index] = game.score

    # Print game information
    print("\rGames played: {}".format(total_games))
    print("Average score: {}".format(sum(game_scores.values())/total_games))
    print("Highest score: {}".format(game_scores[max(game_scores, key=game_scores.get)]))
    print("The algo has beaten {} games".format(games_won))

def fancy_render(board, score, direction, moves):
    """ A more advanced version of the render function """

    # Set the width of the board
    board_spacing = 10

    # Build tile spacing
    tile_spacing = "".join([" " for _ in range(board_spacing)])
    tile_spacing = "||".join([tile_spacing, tile_spacing, tile_spacing, tile_spacing])

    # Build midline
    midline = "".join(["_" for _ in range(board_spacing)])
    midline = "00".join([midline, midline, midline, midline])

    # Build the board
    total_board = ""
    for i, row in enumerate(board):

        # Build the tiles
        tiles = list(map(lambda n: str(" " if n == 0 else n).center(board_spacing, " "), row))
        line = "||".join(tiles)

        if i == 0:
            total_board = "\n".join([tile_spacing, line, tile_spacing])
        else:
            total_board = "\n".join([total_board, midline, tile_spacing, line, tile_spacing])

    # Print the board on the screen
    print(
        f"""
\n\n\n\n\n\n\n\n\n
{total_board}
Movement: {direction}
Score: {score}
Moves: {moves}
        """
    )

# Handle input arguments
# game_mode = ["manual", "automatic"] - Play the game in manual mode or automatic mode
ARGS = game_tools.argument_handler()

if ARGS.game_mode == "manual":
    import lib.network as algo
    manual_game()

elif ARGS.game_mode == "automatic":
    import lib.network as algo
    automatic_game()
