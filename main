#!/usr/bin/env python3.6
import sys
from lib.game import Game

def main():

    # Determine if it is a manual or automatic game
    game_type = "m"
    while game_type not in ["m", "a"]:
        game_type = input('(M)anual game or (A)utoplay?\n').lower()

    # If game is manual played
    if game_type == "m":
        manual_game()
    elif game_type == "a":
        print("Still in progress...")

def manual_game():
    """
    Play the 2048 manually
    """

    # Load an empty game
    game = Game()

    # Set keybinds
    keys = {
        "left": ["a"],
        "right": ["d"],
        "down": ["s"],
        "up": ["w"],
        "quit": ["q"]
    }

    print("Press {} to move left.".format(keys["left"]))
    print("Press {} to move right.".format(keys["right"]))
    print("Press {} to move down.".format(keys["down"]))
    print("Press {} to move up.".format(keys["up"]))
    print("Press {} to quit the game.\n".format(keys["quit"]))
    print("Enjoy!\n___________________\n")

    moves = 0
    draw_board(game.board.board)
    while not game.game_over():

        # Keyboard input
        movement = read_single_keypress()

        # Movements
        if movement in keys["left"] and game.movement_possible("left"):
            moves += 1
            game.left_move()
            draw_board(game.board.board)

        if movement in keys["right"] and game.movement_possible("right"):
            moves += 1
            game.right_move()
            draw_board(game.board.board)

        if movement in keys["down"] and game.movement_possible("down"):
            moves += 1
            game.down_move()
            draw_board(game.board.board)

        if movement in keys["up"] and game.movement_possible("up"):
            moves += 1
            game.up_move()
            draw_board(game.board.board)

        # Quit game
        if movement in keys["quit"]:
            sys.exit()

def draw_board(board):
    """
    Draws 2048 board in the terminal
    """

    # Set the width of the board
    board_spacing = 10

    # Build tile spacing
    tile_spacing = "".join([" " for _ in range(board_spacing)])
    tile_spacing = "||".join([tile_spacing, tile_spacing, tile_spacing, tile_spacing])

    # Build midline
    midline = "".join(["_" for _ in range(board_spacing)])
    midline = "00".join([midline, midline, midline, midline])

    # Build the board
    total_board = ""
    for i, row in enumerate(board):

        # Build the tiles
        tiles = list(map(lambda n: str(" " if n == 0 else n).center(board_spacing, " "), row))
        line = "||".join(tiles)

        if i == 0:
            total_board = "\n".join([tile_spacing, line, tile_spacing])
        else:
            total_board = "\n".join([total_board, midline, tile_spacing, line, tile_spacing])

    # Print the board on the screen
    print("\n\n\n\n\n\n\n\n\n\n\n{}".format(total_board))

def read_single_keypress():
    """Waits for a single keypress on stdin.

    This is a silly function to call if you need to do it a lot because it has
    to store stdin's current setup, setup stdin for reading single keystrokes
    then read the single keystroke then revert stdin back after reading the
    keystroke.

    Returns the character of the key that was pressed (zero on
    KeyboardInterrupt which can happen when a signal gets handled)

    Function obtained from:
    https://stackoverflow.com/questions/983354/how-do-i-make-python-wait-for-a-pressed-key
    """
    import termios, fcntl, sys, os
    fd = sys.stdin.fileno()
    # save old state
    flags_save = fcntl.fcntl(fd, fcntl.F_GETFL)
    attrs_save = termios.tcgetattr(fd)
    # make raw - the way to do this comes from the termios(3) man page.
    attrs = list(attrs_save) # copy the stored version to update
    # iflag
    attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK
                  | termios.ISTRIP | termios.INLCR | termios. IGNCR
                  | termios.ICRNL | termios.IXON )
    # oflag
    attrs[1] &= ~termios.OPOST
    # cflag
    attrs[2] &= ~(termios.CSIZE | termios. PARENB)
    attrs[2] |= termios.CS8
    # lflag
    attrs[3] &= ~(termios.ECHONL | termios.ECHO | termios.ICANON
                  | termios.ISIG | termios.IEXTEN)
    termios.tcsetattr(fd, termios.TCSANOW, attrs)
    # turn off non-blocking
    fcntl.fcntl(fd, fcntl.F_SETFL, flags_save & ~os.O_NONBLOCK)
    # read a single keystroke
    try:
        ret = sys.stdin.read(1) # returns a single character
    except KeyboardInterrupt:
        ret = 0
    finally:
        # restore old state
        termios.tcsetattr(fd, termios.TCSAFLUSH, attrs_save)
        fcntl.fcntl(fd, fcntl.F_SETFL, flags_save)
    return ret

if __name__ == "__main__":
    main()
